"""
SQL WHERE Clause Validator

Provides strict validation for SQL WHERE clauses generated by AI to prevent SQL injection.
Only allows safe ILIKE-based search patterns.
"""

import re
from typing import Tuple


class SQLWhereValidator:
    """Validates SQL WHERE clauses for safety against injection attacks."""

    # Dangerous SQL keywords that should never appear in WHERE clauses
    DANGEROUS_KEYWORDS = {
        "DELETE",
        "UPDATE",
        "DROP",
        "CREATE",
        "ALTER",
        "TRUNCATE",
        "INSERT",
        "UNION",
        "JOIN",
        "EXEC",
        "EXECUTE",
        "DECLARE",
        "GRANT",
        "REVOKE",
        "COMMIT",
        "ROLLBACK",
        "SAVEPOINT",
        "SET",
        "BEGIN",
        "END",
    }

    # Allowed column names for the books table
    ALLOWED_COLUMNS = {
        "title",
        "author",
        "genre",
        "description",
        "isbn",
        "published_date",
    }

    # Allowed operators
    ALLOWED_OPERATORS = {"ILIKE", "NOT ILIKE", "=", "!=", "<", ">", "<=", ">="}

    @classmethod
    def _is_similar_to_dangerous(cls, word: str) -> tuple[bool, str]:
        """Check if word is similar to dangerous keyword using fuzzy matching (catches typos)."""
        from difflib import SequenceMatcher

        word_upper = word.upper()

        # First check exact match
        if word_upper in cls.DANGEROUS_KEYWORDS:
            return True, word_upper

        # Check for fuzzy matches (catches typos)
        for dangerous in cls.DANGEROUS_KEYWORDS:
            # Calculate similarity
            similarity = SequenceMatcher(None, word_upper, dangerous).ratio()

            # If very similar (80%+), it's likely a typo of a dangerous keyword
            if similarity >= 0.8:
                return True, dangerous

            # Also check if word contains the dangerous keyword or vice versa
            # This catches things like "DELETES", "DELETED", etc.
            if len(word_upper) >= 4 and len(dangerous) >= 4:
                if dangerous in word_upper or word_upper in dangerous:
                    return True, dangerous

        return False, ""

    @classmethod
    def validate(cls, where_clause: str) -> Tuple[bool, str]:
        """
        Validate a SQL WHERE clause for safety.

        Args:
            where_clause: The WHERE clause to validate (without 'WHERE' keyword)

        Returns:
            (is_valid, error_message) tuple
        """
        if not where_clause or not where_clause.strip():
            return False, "WHERE clause cannot be empty"

        # Convert to uppercase for keyword checking
        upper_clause = where_clause.upper()

        # 1. Check for dangerous keywords (exact match)
        for keyword in cls.DANGEROUS_KEYWORDS:
            if re.search(r"\b" + keyword + r"\b", upper_clause):
                return False, f"Dangerous keyword detected: {keyword}"

        # 2. Check for typos/variations of dangerous keywords (fuzzy match)
        # Split into words and check each one
        words = re.findall(r"\b[A-Z]+\b", upper_clause)
        for word in words:
            # Skip common safe words
            if word in {"AND", "OR", "NOT", "ILIKE", "FROM", "YEAR", "EXTRACT"}:
                continue

            is_dangerous, matched_keyword = cls._is_similar_to_dangerous(word)
            if is_dangerous:
                return (
                    False,
                    f"Suspicious keyword detected: '{word}' (similar to dangerous keyword: {matched_keyword})",
                )

        # 3. Check for SQL comments
        if "--" in where_clause or "/*" in where_clause or "*/" in where_clause:
            return False, "SQL comments are not allowed"

        # 4. Check for multiple statements (semicolons)
        if ";" in where_clause:
            return False, "Multiple statements are not allowed"

        # 5. Check for subqueries
        if "(" in where_clause and "SELECT" in upper_clause:
            return False, "Subqueries are not allowed"

        # 6. Validate that only allowed columns are referenced
        # Extract potential column names (words before operators)
        potential_columns = re.findall(
            r"\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:ILIKE|NOT\s+ILIKE|=|!=|<|>|<=|>=)",
            where_clause,
            re.IGNORECASE,
        )

        for col in potential_columns:
            if col.lower() not in cls.ALLOWED_COLUMNS:
                return (
                    False,
                    f"Column '{col}' is not allowed. Allowed columns: {', '.join(cls.ALLOWED_COLUMNS)}",
                )

        # 7. Check for SQL functions (except EXTRACT for dates)
        function_pattern = r"\b(?!EXTRACT\b|AND\b|OR\b|NOT\b)[A-Z_]+\s*\("
        if re.search(function_pattern, upper_clause):
            return False, "SQL functions are not allowed (except EXTRACT for dates)"

        # 8. Check for balanced parentheses
        if where_clause.count("(") != where_clause.count(")"):
            return False, "Unbalanced parentheses detected"

        # 9. Validate ILIKE patterns - must use single quotes
        ilike_patterns = re.findall(r"ILIKE\s+([^\s]+)", upper_clause)
        for pattern in ilike_patterns:
            if not pattern.startswith("'"):
                return False, "ILIKE patterns must use single quotes"

        # 10. Ensure only AND/OR for logical operations
        logical_ops = re.findall(r"\b(AND|OR|NOT)\b", upper_clause)
        for op in logical_ops:
            if op not in ["AND", "OR", "NOT"]:
                return False, f"Logical operator '{op}' is not allowed"

        # 11. Check for valid operators only
        operators_found = re.findall(
            r"\b(ILIKE|NOT\s+ILIKE)\b|([=!<>]+)", where_clause, re.IGNORECASE
        )
        for op_tuple in operators_found:
            op = op_tuple[0] if op_tuple[0] else op_tuple[1]
            if (
                op
                and op.upper().strip() not in cls.ALLOWED_OPERATORS
                and op not in ["=", "!=", "<", ">", "<=", ">="]
            ):
                # Allow basic comparison operators even if not in uppercase
                if op not in ["=", "!", "<", ">"]:
                    return False, f"Operator '{op}' is not allowed"

        return True, "Valid WHERE clause"

    @classmethod
    def sanitize_value(cls, value: str) -> str:
        """
        Sanitize a string value for use in SQL.
        Escapes single quotes and validates format.

        Args:
            value: The value to sanitize

        Returns:
            Sanitized value wrapped in single quotes
        """
        # Escape single quotes
        sanitized = value.replace("'", "''")
        return f"'{sanitized}'"


def validate_where_clause(where_clause: str) -> Tuple[bool, str]:
    """
    Convenience function to validate a WHERE clause.

    Args:
        where_clause: SQL WHERE clause to validate

    Returns:
        (is_valid, error_message) tuple
    """
    return SQLWhereValidator.validate(where_clause)
